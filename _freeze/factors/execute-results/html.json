{
  "hash": "eb5bec1a20a3c34dc50995646a9ca257",
  "result": {
    "engine": "knitr",
    "markdown": "ADD demo of `cut_number()`, `cut_interval()`, and related functions for making factors from numeric data\n\n# Factors\n\nread\n\nhttps://r4ds.had.co.nz/factors.html\n\nhttps://www.kaggle.com/datasets/dillonmyrick/high-school-student-performance-and-demographics\n\nhttps://www.kaggle.com/datasets/dillonmyrick/high-school-student-performance-and-demographics\n\nhttps://www.kaggle.com/datasets/uom190346a/sleep-health-and-lifestyle-dataset\n\n## Classing as factor\n\nx1 <- c(\"Dec\", \"Apr\", \"Jan\", \"Mar\")\nx2 <- c(\"Dec\", \"Apr\", \"Jam\", \"Mar\")\n\nmonth_levels <- c(\n  \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \n  \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n)\n\ny1 <- fct(x1, levels = month_levels)\n\ny2 <- fct(x2, levels = month_levels)\n\nfct will produce error if value noy in levels when levels supplied\n\nlevels(y2)\n\n\n\nYou can also create a factor when reading your data with readr with col_factor():\n\ncsv <- \"\nmonth,value\nJan,12\nFeb,56\nMar,12\"\n\ndf <- read_csv(csv, col_types = cols(month = col_factor(month_levels)))\ndf$month\n\n\n\n## EDA\n\n\ngss_cat |>\n  count(race)\n  \nbar graph\n\n\n## Modifying order\n\n\n### fct_reorder\nrelig_summary <- gss_cat |>\n  group_by(relig) |>\n  summarize(\n    tvhours = mean(tvhours, na.rm = TRUE),\n    n = n()\n  )\n  \n  relig_summary |>\n  mutate(\n    relig = fct_reorder(relig, tvhours)\n  ) |>\n  ggplot(aes(x = tvhours, y = relig)) +\n  geom_point()\n  \n  ### fct_relevel\n  \n  However, it does make sense to pull “Not applicable” to the front with the other special levels. You can use fct_relevel(). It takes a factor, f, and then any number of levels that you want to move to the front of the line.\n\nggplot(rincome_summary, aes(x = age, y = fct_relevel(rincome, \"Not applicable\"))) +\n  geom_point()\n  \n### fct_infreq & fct_rev\n  \n  Finally, for bar plots, you can use fct_infreq() to order levels in decreasing frequency: this is the simplest type of reordering because it doesn’t need any extra variables. Combine it with fct_rev() if you want them in increasing frequency so that in the bar plot largest values are on the right, not the left.\n\ngss_cat |>\n  mutate(marital = marital |> fct_infreq() |> fct_rev()) |>\n  ggplot(aes(x = marital)) +\n  geom_bar()\n\t\n\t\nfct_inseq(): by numeric value of level.\n\n\n  \n## Modifying factor levels\n\n\n### fct_recode\n  \n  gss_cat |>\n  mutate(\n    partyid = fct_recode(partyid,\n      \"Republican, strong\"    = \"Strong republican\",\n      \"Republican, weak\"      = \"Not str republican\",\n      \"Independent, near rep\" = \"Ind,near rep\",\n      \"Independent, near dem\" = \"Ind,near dem\",\n      \"Democrat, weak\"        = \"Not str democrat\",\n      \"Democrat, strong\"      = \"Strong democrat\"\n    )\n  ) \n  \n  \n  fct_recode() will leave the levels that aren’t explicitly mentioned as is, and will warn you if you accidentally refer to a level that doesn’t exist\n  \n  \n  To combine groups, you can assign multiple old levels to the same new level:\n\ngss_cat |>\n  mutate(\n    partyid = fct_recode(partyid,\n      \"Republican, strong\"    = \"Strong republican\",\n      \"Republican, weak\"      = \"Not str republican\",\n      \"Independent, near rep\" = \"Ind,near rep\",\n      \"Independent, near dem\" = \"Ind,near dem\",\n      \"Democrat, weak\"        = \"Not str democrat\",\n      \"Democrat, strong\"      = \"Strong democrat\",\n      \"Other\"                 = \"No answer\",\n      \"Other\"                 = \"Don't know\",\n      \"Other\"                 = \"Other party\"\n    )\n  )\n  \n  \n  \nIf we want to manipulate a numeric vector, first coerce it to a character, and then recode it. We need to be sure to quote the right half of each of our recoding pairs, since survey’s values are now character (e.g., \"1\") rather than numeric (1).\n\nsurvey <- fct_recode(as.character(survey),\n                     \"Strongly agree\" = \"1\", \n                     \"Agree\" = \"2\", \n                     \"Neither agree nor disagree\" = \"3\",\n                     \"Disagree\" = \"4\",\n                     \"Strongly disagree\" = \"5\")\n  \n  \n### fct_collapse\n\nIf you want to collapse a lot of levels, fct_collapse() is a useful variant of fct_recode(). For each new variable, you can provide a vector of old levels:\n\ngss_cat |>\n  mutate(\n    partyid = fct_collapse(partyid,\n      \"other\" = c(\"No answer\", \"Don't know\", \"Other party\"),\n      \"rep\" = c(\"Strong republican\", \"Not str republican\"),\n      \"ind\" = c(\"Ind,near rep\", \"Independent\", \"Ind,near dem\"),\n      \"dem\" = c(\"Not str democrat\", \"Strong democrat\")\n    )\n  )\n\n\n\n## Setting Factor Contrasts \n\nNOTE: THIS CAN BE UPDATED TO SIMPLIFY TO JUST SET THE COEFFFICIENTS DIRECTLY.  ITS EASIER\n\n* see: https://marissabarlaz.github.io/portfolio/contrastcoding/\n* Default for unordered factors is treatment/dummy\n* We typically want centered orthogonal, and unit weighted.\n- We will use a running example of a factor, $x$, with three levels. We put $x$ in a dataframe to match our typical workflows\n- We then follow with several examples of setting and applying contrasts to $x$\n\n### Sample data\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nd <- tibble(x = factor(rep(c(\"A\",\"B\", \"C\"), 4)))\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 1\n   x    \n   <fct>\n 1 A    \n 2 B    \n 3 C    \n 4 A    \n 5 B    \n 6 C    \n 7 A    \n 8 B    \n 9 C    \n10 A    \n11 B    \n12 C    \n```\n\n\n:::\n:::\n\n\n### Default contrasts\n\n\nThe default contrasts for factors in R as set and viewed using `options()`\n\n- They are contr.treatment (i.e., dummy codes) for unordered factors\n- They are contr.poly for ordered factors\n- We do not tend to change these defaults but instead explicitly set other contrasts when we need them\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(\"contrasts\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$contrasts\n        unordered           ordered \n\"contr.treatment\"      \"contr.poly\" \n```\n\n\n:::\n:::\n\n\nWe can confirm the contrasts set by default for $x$ as follows\n\n- They are dummy codes\n- They are named for the level being contrasted with refererence \n\n::: {.cell}\n\n```{.r .cell-code}\ncontrasts(d$x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  B C\nA 0 0\nB 1 0\nC 0 1\n```\n\n\n:::\n:::\n\n\n### Base R approach for other contrasts\n\nWe set contrasts using the `contrasts()` function as well.  We *could* use base R functions that define contrast matrices for classic contrasts as well\n\n- But the coefficients aren't united weighted (my preference)\n- And the contrasts aren't given descriptive labels\n\n::: {.cell}\n\n```{.r .cell-code}\ncontrasts(d$x) <- contr.helmert(levels(d$x))\ncontrasts(d$x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [,1] [,2]\nA   -1   -1\nB    1   -1\nC    0    2\n```\n\n\n:::\n:::\n\n\n\n### An improved approach\n\n\nWe tweak this approach to get unit weights (only for Helmert) and meaningful contrast labels\n\n- First we get the contrast matrix (same as above)\n\n::: {.cell}\n\n```{.r .cell-code}\nc3 <- contr.helmert(levels(d$x))\nc3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [,1] [,2]\nA   -1   -1\nB    1   -1\nC    0    2\n```\n\n\n:::\n:::\n\n\n- Then we adjust to make coefficients unit-weighted.  This simply requires dividing each column by its range.  You could put this in a loop if you had more columns.  We generally only do this for helmert or other orthogonal contrasts. \n\n::: {.cell}\n\n```{.r .cell-code}\nc3[, 1] <- c3[, 1] / (max(c3[, 1]) - min(c3[, 1]))\nc3[, 2] <- c3[, 2] / (max(c3[, 2]) - min(c3[, 2]))\n```\n:::\n\n\n- Now assign names to the columns to label the contrasts\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(c3) <- c(\"BvA\", \"CvBA\")\nc3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   BvA       CvBA\nA -0.5 -0.3333333\nB  0.5 -0.3333333\nC  0.0  0.6666667\n```\n\n\n:::\n:::\n\n\n- And now assign these contrasts to $x$\n\n::: {.cell}\n\n```{.r .cell-code}\ncontrasts(d$x) <- c3\ncontrasts(d$x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   BvA       CvBA\nA -0.5 -0.3333333\nB  0.5 -0.3333333\nC  0.0  0.6666667\n```\n\n\n:::\n:::\n\n\n\n### Available contrasts\n\nThe contrasts we use most regularly are \n\n- Dummy contrasts (`contr.treatment()`).  These are set by default to unordered factors\n- Helmert contrasts (`contrl.helmert()`). \n- Effects constrasts (`contr.sum()`).  We do not generally unit weight these",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}