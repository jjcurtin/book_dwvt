{
  "hash": "2995a258989ea38031a53d2cc3675d91",
  "result": {
    "engine": "knitr",
    "markdown": "# Exploring date-times and dates with lubridate\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(lubridate)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npath <- \"data\" \n```\n:::\n\n\n## Date-times/dttm\n* Create a tibble with a date as a character string\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- tibble(t = c(\"2017-01-27 12:01:00\", \"2017-01-27 23:59:00\", \"2017-01-27 00:01:00\")) %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 3\nColumns: 1\n$ t <chr> \"2017-01-27 12:01:00\", \"2017-01-27 23:59:00\", \"2017-01-27 00:01:00\"\n```\n\n\n:::\n:::\n\n\nCan use as_datetime to class as dttm\n\n* defaults to assuming character string is in UTC tz\n* will class as dttm in UTC\n\n::: {.cell}\n\n```{.r .cell-code}\nd %>% \n  mutate(t_dttm = as_datetime(t)) %>% \n  print() %>% \n  pull(t_dttm) %>% \n  print()  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  t                   t_dttm             \n  <chr>               <dttm>             \n1 2017-01-27 12:01:00 2017-01-27 12:01:00\n2 2017-01-27 23:59:00 2017-01-27 23:59:00\n3 2017-01-27 00:01:00 2017-01-27 00:01:00\n[1] \"2017-01-27 12:01:00 UTC\" \"2017-01-27 23:59:00 UTC\"\n[3] \"2017-01-27 00:01:00 UTC\"\n```\n\n\n:::\n:::\n\n\n* Can class character string as dttm in another timezone with $tz$ argument\n* Will class as dttm in that other timezone retaining original values but just with different timezone\n\n::: {.cell}\n\n```{.r .cell-code}\nd %>% \n  mutate(t_dttm = as_datetime(t, tz= \"America/Chicago\")) %>% \n  print() %>% \n  pull(t_dttm) %>% \n  print()  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  t                   t_dttm             \n  <chr>               <dttm>             \n1 2017-01-27 12:01:00 2017-01-27 12:01:00\n2 2017-01-27 23:59:00 2017-01-27 23:59:00\n3 2017-01-27 00:01:00 2017-01-27 00:01:00\n[1] \"2017-01-27 12:01:00 CST\" \"2017-01-27 23:59:00 CST\"\n[3] \"2017-01-27 00:01:00 CST\"\n```\n\n\n:::\n:::\n\n\n* Can class character string as dttm in another timezone with $tz$\n* AND THEN change timezone (e.g., orginal values were in America/Chicago and then change to UTC tz)\n* $with\\_tz()$ returns same moment of time in another timezone\n\n::: {.cell}\n\n```{.r .cell-code}\nd %>% \n  mutate(t_dttm = as_datetime(t, tz= \"America/Chicago\"),\n         t_dttm = with_tz(t_dttm, tz = \"UTC\")) %>% \n  print() %>% \n  pull(t_dttm) %>% \n  print()  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  t                   t_dttm             \n  <chr>               <dttm>             \n1 2017-01-27 12:01:00 2017-01-27 18:01:00\n2 2017-01-27 23:59:00 2017-01-28 05:59:00\n3 2017-01-27 00:01:00 2017-01-27 06:01:00\n[1] \"2017-01-27 18:01:00 UTC\" \"2017-01-28 05:59:00 UTC\"\n[3] \"2017-01-27 06:01:00 UTC\"\n```\n\n\n:::\n:::\n\n\n* Can force a shift of the time zone keeping the actual time value the same\n* This is a NEW moment in time.  \n* Do if the dttm already has a tz and it is WRONG\n* See $force_tzs()$ if you have dttm in same column which need to be shifted to varied tzs\n  * All values in a column in R need to have same tz\n  * $force\\_tzs()$ can accomodate this b/c forcing the tz changes and then returning all values in one time zone (with that latter adjustement preserving their new moments in time)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd %>% \n  mutate(t_dttm = as_datetime(t, tz= \"America/Chicago\"),\n         t_dttm_forced = force_tz(t_dttm, tzone = \"UTC\")) %>% \n  print() %>% \n  pull(t_dttm_forced) %>% \n  print()  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  t                   t_dttm              t_dttm_forced      \n  <chr>               <dttm>              <dttm>             \n1 2017-01-27 12:01:00 2017-01-27 12:01:00 2017-01-27 12:01:00\n2 2017-01-27 23:59:00 2017-01-27 23:59:00 2017-01-27 23:59:00\n3 2017-01-27 00:01:00 2017-01-27 00:01:00 2017-01-27 00:01:00\n[1] \"2017-01-27 12:01:00 UTC\" \"2017-01-27 23:59:00 UTC\"\n[3] \"2017-01-27 00:01:00 UTC\"\n```\n\n\n:::\n:::\n\n\n* When using `write_csv()` and `vroom_write()`, dttm is converted to UTC first\n  * A Z is appended to time to indicate (Z)ero time shift\n  * Change back to appropriate timezone using `with_tz()` in a `mutate()`\n* The character string t is written as a character string\n  * It was not a dttm so it is not converted to UTC\n  * It has no Z\n  * HOWEVER, when you read this back, it will assume UTC!!!!\n  * You will need to use $force\\_tz()$ if it was actually in another tz\n  * Open dttm_output.csv to see this behavior\n\n::: {.cell}\n\n```{.r .cell-code}\nd %>% \n  mutate(t_dttm = as_datetime(t, tz= \"America/Chicago\")) %>% \n  print() %>% \n  write_csv(file.path(path, \"dttm_output.csv\")) %>% \n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  t                   t_dttm             \n  <chr>               <dttm>             \n1 2017-01-27 12:01:00 2017-01-27 12:01:00\n2 2017-01-27 23:59:00 2017-01-27 23:59:00\n3 2017-01-27 00:01:00 2017-01-27 00:01:00\n# A tibble: 3 × 2\n  t                   t_dttm             \n  <chr>               <dttm>             \n1 2017-01-27 12:01:00 2017-01-27 12:01:00\n2 2017-01-27 23:59:00 2017-01-27 23:59:00\n3 2017-01-27 00:01:00 2017-01-27 00:01:00\n```\n\n\n:::\n:::\n\n\n* When reading dttm_output.csv, t_dttm is clearly UTC with Z suffix\n* t is clearly an R formatted date-time it is classed as dttm\n  * It had no tz info so it is assumed to be in UTC!\n  * Shift it to get back to whatever tz you want/need usig $force\\_tz()$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_csv <- read_csv(file.path(path, \"dttm_output.csv\")) %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 3\nColumns: 2\n$ t      <dttm> 2017-01-27 12:01:00, 2017-01-27 23:59:00, 2017-01-27 00:01:00\n$ t_dttm <dttm> 2017-01-27 18:01:00, 2017-01-28 05:59:00, 2017-01-27 06:01:00\n```\n\n\n:::\n\n```{.r .cell-code}\nd_csv$t   # CAREFUL if t wasn't in UTC before, this has changed its moment in time when setting to UTC.\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2017-01-27 12:01:00 UTC\" \"2017-01-27 23:59:00 UTC\"\n[3] \"2017-01-27 00:01:00 UTC\"\n```\n\n\n:::\n\n```{.r .cell-code}\nd_csv$t_dttm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2017-01-27 18:01:00 UTC\" \"2017-01-28 05:59:00 UTC\"\n[3] \"2017-01-27 06:01:00 UTC\"\n```\n\n\n:::\n:::\n\n\n\n## Dates\n\n* Use $as\\_date()$ to convert character string to date\n* date class does NOT have tz\n\n::: {.cell}\n\n```{.r .cell-code}\n(a_date = as_date(\"2017-01-27\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2017-01-27\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(a_date)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Date\"\n```\n\n\n:::\n:::\n\n\n* Can strip time from dttm with $as\\_date()$\n* $as_date() ignores tz and just parse out the date portion of the dttm\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(a_dttm = as_datetime(\"2017-01-27 23:59:01\", tz = \"America/Chicago\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2017-01-27 23:59:01 CST\"\n```\n\n\n:::\n\n```{.r .cell-code}\nas_date(a_dttm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2017-01-27\"\n```\n\n\n:::\n\n```{.r .cell-code}\n(a_dttm = as_datetime(\"2017-01-27 23:59:01\", tz = \"UTC\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2017-01-27 23:59:01 UTC\"\n```\n\n\n:::\n\n```{.r .cell-code}\nas_date(a_dttm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2017-01-27\"\n```\n\n\n:::\n:::\n\n\n\n* Note that base R as.Date() works differently with respect to how it handles the tz of the dttm\n* We will always use $as\\_date()$\n\n::: {.cell}\n\n```{.r .cell-code}\n(a_dttm = as_datetime(\"2017-01-27 23:59:01\", tz = \"America/Chicago\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2017-01-27 23:59:01 CST\"\n```\n\n\n:::\n\n```{.r .cell-code}\nas.Date(a_dttm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2017-01-28\"\n```\n\n\n:::\n\n```{.r .cell-code}\n(a_dttm = as_datetime(\"2017-01-27 23:59:01\", tz = \"UTC\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2017-01-27 23:59:01 UTC\"\n```\n\n\n:::\n\n```{.r .cell-code}\nas.Date(a_dttm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2017-01-27\"\n```\n\n\n:::\n:::\n\n\n* When writing to csv, outputs as character.  Since no tz, not tz stamp is needed\n* When reading, the character string is automatically converted to date class\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- tibble(dates = c(\"2017-01-27\", \"2017-01-28\",\"2017-01-29\")) %>% \n  mutate(dates_asdates = as_date(dates)) %>% \n  glimpse() %>% \n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 3\nColumns: 2\n$ dates         <chr> \"2017-01-27\", \"2017-01-28\", \"2017-01-29\"\n$ dates_asdates <date> 2017-01-27, 2017-01-28, 2017-01-29\n# A tibble: 3 × 2\n  dates      dates_asdates\n  <chr>      <date>       \n1 2017-01-27 2017-01-27   \n2 2017-01-28 2017-01-28   \n3 2017-01-29 2017-01-29   \n```\n\n\n:::\n\n```{.r .cell-code}\nwrite_csv(d, file.path(path, \"date_output.csv\"))\n\nd_csv <- read_csv(file.path(path, \"date_output.csv\")) %>% \n  glimpse() %>% \n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 3\nColumns: 2\n$ dates         <date> 2017-01-27, 2017-01-28, 2017-01-29\n$ dates_asdates <date> 2017-01-27, 2017-01-28, 2017-01-29\n# A tibble: 3 × 2\n  dates      dates_asdates\n  <date>     <date>       \n1 2017-01-27 2017-01-27   \n2 2017-01-28 2017-01-28   \n3 2017-01-29 2017-01-29   \n```\n\n\n:::\n:::\n\n\n\n## Converting unix times\n\n::: {.cell}\n\n```{.r .cell-code}\n# https://www.epochconverter.com/\n# Epoch timestamp: 1485540001\n# Timestamp in milliseconds: 1485540001000\n# Human time (GMT): Friday, January 27, 2017 6:00:01 PM\n# Human time (your time zone): Friday, January 27, 2017 12:00:01 PM GMT-06:00\n\nas_datetime(1485540001)  #assumes origin is 1970-01-01 unix time and returns UTC timezone\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2017-01-27 18:00:01 UTC\"\n```\n\n\n:::\n\n```{.r .cell-code}\nas_datetime(1485540001, tz='America/Chicago') # same moment in time in different time zone\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2017-01-27 12:00:01 CST\"\n```\n\n\n:::\n:::\n\n\n\n## Conclusions\n\nLab practices:\n\n* Only use lubridate functions for manipulation of date-time and date objects\n* Recognize that dttm columns saved/read from csv in UTC with Z timezone stamp\n* Qualtrics doesn't timestamp its time variables.  We will set up qualtrics to always export in UTC\n* We can change timezones in our scripts as needed (or leave in UTC)\n* All lubridate functions respect the tz of dttm\n* Dates do NOT have timezones.  Need to think carefully if converting a dttm column to date class\n* We do not need to name variables per their timezone b/c tz is preserved in the units (see exception for qualtrics)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}