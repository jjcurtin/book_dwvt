{
  "hash": "f64a158acaa51b6f6068ee012463fa6c",
  "result": {
    "engine": "knitr",
    "markdown": "---\neditor_options: \n  chunk_output_type: console\n---\n\n\n# Exploring dataframes\n\nMake an example data frame to explore \n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nN = 10\nd <- tibble(x1 = rnorm(N, 10, 2), \n            x2 = rnorm(N, 10, 2),\n            y1 = sample(letters, N, replace = TRUE), \n            y2 = sample(letters, N, replace = TRUE), \n            z = sample(c(\"dog\", \"cat\", \"fish\"), N, replace = TRUE)) |> \n  mutate(z = fct(z, levels = c(\"dog\", \"cat\", \"fish\")))\n```\n:::\n\n\n## glimpse() \n\n`glimpse()`\n\n-  Provides info about nrows, ncols, column names, column types and a \"glimpse\" of some of the data in each column\n- returns the tibble so can be used at the end of a pipe when you first read the data with `read_csv()` or similar\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd |> glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 10\nColumns: 5\n$ x1 <dbl> 9.864656, 10.648627, 9.370226, 8.208932, 7.798212, 10.212464, 11.69…\n$ x2 <dbl> 9.760840, 12.671562, 10.331021, 4.643704, 11.381113, 13.237035, 9.0…\n$ y1 <chr> \"b\", \"o\", \"q\", \"j\", \"e\", \"c\", \"l\", \"j\", \"a\", \"l\"\n$ y2 <chr> \"h\", \"e\", \"a\", \"v\", \"x\", \"v\", \"y\", \"r\", \"v\", \"w\"\n$ z  <fct> fish, cat, dog, fish, fish, fish, cat, cat, cat, fish\n```\n\n\n:::\n:::\n\n\n## Rows, Columns, and Names\n\nIf you don't glimpse the dataframe, you should at least check the number of rows and columns, and review the column names\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd |> nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\nd |> ncol()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n\n```{.r .cell-code}\nd |> names()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"x1\" \"x2\" \"y1\" \"y2\" \"z\" \n```\n\n\n:::\n:::\n\n\n## Viewing the dataframe directly\n\nI often use `view()` interactively with the data but `view()` does not work when rendering quarto documents.   You should use `head()`, `tail()`, or `slice_sample()` if you want the output saved in your quarto report. \n\n`head()`, `tail()` or `slice_sample()`\n\n- `head()` and `tail()` returns the first or last 6 rows of the tibble.  Can be changed using `n = argument`j\n- `slice_sample()` returns a random row from the tibble.  Can be changed to more rows using `n = argument`\n- I find that showing someone some rows with these functions makes the data more real to them.  However, works best where there are only a few columns so that they can all be displayed in the console\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd |> head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 5\n     x1    x2 y1    y2    z    \n  <dbl> <dbl> <chr> <chr> <fct>\n1  9.86  9.76 b     h     fish \n2 10.6  12.7  o     e     cat  \n3  9.37 10.3  q     a     dog  \n4  8.21  4.64 j     v     fish \n5  7.80 11.4  e     x     fish \n6 10.2  13.2  c     v     fish \n```\n\n\n:::\n\n```{.r .cell-code}\nd |> tail (n = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 5\n     x1    x2 y1    y2    z    \n  <dbl> <dbl> <chr> <chr> <fct>\n1  8.88 11.0  j     r     cat  \n2  9.12  9.21 a     v     cat  \n3 12.4   9.38 l     w     fish \n```\n\n\n:::\n\n```{.r .cell-code}\nd |> slice_sample(n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 5\n     x1    x2 y1    y2    z    \n  <dbl> <dbl> <chr> <chr> <fct>\n1 11.7   9.03 l     y     cat  \n2  7.80 11.4  e     x     fish \n3  8.88 11.0  j     r     cat  \n4  9.12  9.21 a     v     cat  \n5 10.6  12.7  o     e     cat  \n```\n\n\n:::\n:::\n\n\n## skim()\n\n`skim()`\n\n- Included in the `skimr` package\n- Provides a detailed summary of the dataframe\n- But the output takes up too much space\n- Can use `yank()` to select only the data types you want to see and you can limit to only some columns if needed. \n- Can customize skim to return only the descriptives you want\n\n### Make your own skimmer\n\nLets start with a custom skim that returns only the descriptives I generally want\n\n- Easiest to start with the base skim() \n- Then remove statistics you don't want by setting to NULL\n- Then add any statistics you do want (see example below for syntax)\n- Do this for each data type\n- However, for base (which are reported for all data types), you can't remove and add, you just need to set what you want\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(skimr)\n\nmy_skim <- skim_with(base = sfl(n_complete = ~ sum(!is.na(.), na.rm = TRUE),\n                                n_missing = ~sum(is.na(.), na.rm = TRUE)),\n                     numeric = sfl(p25 = NULL,\n                                   p75 = NULL,\n                                   hist = NULL),\n                     character = sfl(min = NULL, max = NULL),\n                     factor = sfl(ordered = NULL))\n```\n:::\n\n\n### Use with all variables \n\nFirst with all output at once.  Does provide summary tables with nrows, ncols, and counts of columns of each datatype.  Maybe fine to start (though a bit verbose)\n\n::: {.cell}\n\n```{.r .cell-code}\nd |> my_skim()\n```\n\n::: {.cell-output-display}\n\nTable: Data summary\n\n|                         |     |\n|:------------------------|:----|\n|Name                     |d    |\n|Number of rows           |10   |\n|Number of columns        |5    |\n|_______________________  |     |\n|Column type frequency:   |     |\n|character                |2    |\n|factor                   |1    |\n|numeric                  |2    |\n|________________________ |     |\n|Group variables          |None |\n\n\n**Variable type: character**\n\n|skim_variable | n_complete| n_missing| empty| n_unique| whitespace|\n|:-------------|----------:|---------:|-----:|--------:|----------:|\n|y1            |         10|         0|     0|        8|          0|\n|y2            |         10|         0|     0|        8|          0|\n\n\n**Variable type: factor**\n\n|skim_variable | n_complete| n_missing| n_unique|top_counts             |\n|:-------------|----------:|---------:|--------:|:----------------------|\n|z             |         10|         0|        3|fis: 5, cat: 4, dog: 1 |\n\n\n**Variable type: numeric**\n\n|skim_variable | n_complete| n_missing|  mean|   sd|   p0|   p50|  p100|\n|:-------------|----------:|---------:|-----:|----:|----:|-----:|-----:|\n|x1            |         10|         0|  9.82| 1.47| 7.80|  9.62| 12.44|\n|x2            |         10|         0| 10.06| 2.39| 4.64| 10.05| 13.24|\n\n\n:::\n:::\n\n\n### Use with specific data types\nI prefer to `yank()` a class/type at a time but then we don't see rows and columns and all classes present.   Could combine with `nrow()` and `ncol()`\n\n::: {.cell}\n\n```{.r .cell-code}\nd |> my_skim() |> \n  yank(\"numeric\")\n```\n\n::: {.cell-output-display}\n\n\n**Variable type: numeric**\n\n|skim_variable | n_complete| n_missing|  mean|   sd|   p0|   p50|  p100|\n|:-------------|----------:|---------:|-----:|----:|----:|-----:|-----:|\n|x1            |         10|         0|  9.82| 1.47| 7.80|  9.62| 12.44|\n|x2            |         10|         0| 10.06| 2.39| 4.64| 10.05| 13.24|\n\n\n\n:::\n\n```{.r .cell-code}\nd |> my_skim() |> \n yank(\"character\")\n```\n\n::: {.cell-output-display}\n\n\n**Variable type: character**\n\n|skim_variable | n_complete| n_missing| empty| n_unique| whitespace|\n|:-------------|----------:|---------:|-----:|--------:|----------:|\n|y1            |         10|         0|     0|        8|          0|\n|y2            |         10|         0|     0|        8|          0|\n\n\n\n:::\n\n```{.r .cell-code}\nd |> my_skim() |> \n  yank(\"factor\")\n```\n\n::: {.cell-output-display}\n\n\n**Variable type: factor**\n\n|skim_variable | n_complete| n_missing| n_unique|top_counts             |\n|:-------------|----------:|---------:|--------:|:----------------------|\n|z             |         10|         0|        3|fis: 5, cat: 4, dog: 1 |\n\n\n\n:::\n:::\n\n\n### Limit output to specific columns\n\nWe can limit the dataframes returned by skimr to a subset of the variables/columns in the original data\n\n- This can be done across or within a data type\n- Columns can be selected using tidy select functions\n- Can be combined with `yank()` to limit the output to specific data types if your selected columns are all the same type\n\n::: {.cell}\n\n```{.r .cell-code}\nd |> my_skim(x1, y2) \n```\n\n::: {.cell-output-display}\n\nTable: Data summary\n\n|                         |     |\n|:------------------------|:----|\n|Name                     |d    |\n|Number of rows           |10   |\n|Number of columns        |5    |\n|_______________________  |     |\n|Column type frequency:   |     |\n|character                |1    |\n|numeric                  |1    |\n|________________________ |     |\n|Group variables          |None |\n\n\n**Variable type: character**\n\n|skim_variable | n_complete| n_missing| empty| n_unique| whitespace|\n|:-------------|----------:|---------:|-----:|--------:|----------:|\n|y2            |         10|         0|     0|        8|          0|\n\n\n**Variable type: numeric**\n\n|skim_variable | n_complete| n_missing| mean|   sd|  p0|  p50|  p100|\n|:-------------|----------:|---------:|----:|----:|---:|----:|-----:|\n|x1            |         10|         0| 9.82| 1.47| 7.8| 9.62| 12.44|\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nd |> my_skim(contains(\"x\")) |> \n  yank(\"numeric\")\n```\n\n::: {.cell-output-display}\n\n\n**Variable type: numeric**\n\n|skim_variable | n_complete| n_missing|  mean|   sd|   p0|   p50|  p100|\n|:-------------|----------:|---------:|-----:|----:|----:|-----:|-----:|\n|x1            |         10|         0|  9.82| 1.47| 7.80|  9.62| 12.44|\n|x2            |         10|         0| 10.06| 2.39| 4.64| 10.05| 13.24|\n\n\n\n:::\n:::\n\n\n## Limit output to specific descriptive statistics\n\nWe can limit the dataframes returned by skimr to a subset of the statistics using `focus()`\n\n- This is a variant of `dplyr::select()` but safer to use with skimmer dataframes\n- This can be done across or within a data type\n- Must pre-pend column name with data type (and a `.`)\n- Columns can be selected using tidy select functions\n- Can be combined with `yank()` to limit the output to specific data types\n\n::: {.cell}\n\n```{.r .cell-code}\nd |> my_skim() |>\n  focus(n_missing, numeric.mean) |> \n  yank(\"numeric\")\n```\n\n::: {.cell-output-display}\n\n\n**Variable type: numeric**\n\n|skim_variable | n_missing|  mean|\n|:-------------|---------:|-----:|\n|x1            |         0|  9.82|\n|x2            |         0| 10.06|\n\n\n\n:::\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}