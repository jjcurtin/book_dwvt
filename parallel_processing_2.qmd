---
editor_options: 
  chunk_output_type: console
---
# Parallel Processing

```{r}
library(tidyverse)
library(tidymodels)
options(conflicts.policy = "depends.ok")

library(future)
library(tictoc)  # for crude timing to evaluate benefits
library(furrr)
library(foreach, exclude = c("accumulate", "when"))

# source
source("https://github.com/jjcurtin/lab_support/blob/main/fun_ml.R?raw=true")
```

The [furrr](https://cran.r-project.org/web/packages/furrr/index.html) package provides a parallel version of the map functions for iteration.   The developers provide useful [documentation and deep dives](https://furrr.futureverse.org/) that are worth reading when you start using `future_map()` and its variants.

[foreach](https://cran.r-project.org/web/packages/foreach/vignettes/foreach.html) provides an alternative for loop that can run sequentially or in parallel as requested.  Previously, `foreach` was used under the hood to do resampling by `fit_resamples()` and `tune_grid()` in tidymodels.  However, this has been replaced by the same backend used by furrr (future) as of tune 1.2.1.

Michael Hallquist has provided a useful and detailed [overview](https://psu-psychology.github.io/r-bootcamp-2018/talks/parallel_r.html) of parallel processing.   It is a good first read to orient to terms and concepts.  However, it does not describe either the `future` package or the `furrr` package.  It does provide brief introduction to `foreach`

[Info on future ecosystem](https://dcgerard.github.io/advancedr/09_future.html) and [more](https://cran.r-project.org/web/packages/future/vignettes/future-3-topologies.html)

[Parallel processing and other optimizations](https://tune.tidymodels.org/articles/extras/optimizations.html) in tidymodels.  Also see `?tune::parallelism()`


Here are the number of physical (not logical) cores on this machine.  You may have more or less
```{r}
parallel::detectCores(logical = FALSE)
```


### future_map()

Here is the use of map (that uses sequential processing)
```{r}
tic()
x <- map(c(2, 2, 2), \(time) Sys.sleep(time))
toc()
```

Using `future_map()` without a plan (Don't do this!)
```{r}
tic()
x <- future_map(c(2, 2, 2), \(time) Sys.sleep(time))
toc()
```

Using `future_map()` with a plan (Do this!)
```{r}
# library(future)  # need this loaded at top of script to use plan()
plan(multisession, workers = parallel::detectCores(logical = FALSE))

tic()
x <- future_map(c(2, 2, 2), \(time) Sys.sleep(time))
toc()

plan(sequential)
```



## tune_grid() in tidymodels

Set up data, resamples, recipe, tuning grid. Will do 3x 10-fold CV to tune an ElasticNet glm with a sample size of 1000 and 30 features
```{r}
# set up data
n_obs <- 1000
n_x <- 30
irr_err <- 5
d <- MASS::mvrnorm(n = n_obs, mu = rep(0,n_x), Sigma = diag(n_x)) %>% 
    magrittr::set_colnames(str_c("x", 1:n_x)) %>% 
    as_tibble() %>% 
    mutate(error = rnorm(n_obs, 0, irr_err),
           y = rowSums(across(everything()))) %>% 
    select(-error)

# recipe
rec <- recipe(y ~ ., data = d)

# 10-fold CV
set.seed(19690127)
splits <- d %>% 
  vfold_cv(v = 10, strata = "y")

# tuning grid
tune_grid <- expand_grid(penalty = exp(seq(0, 6, length.out = 200)),
                           mixture = seq(0, 1, length.out = 11))
```

First, let's benchmark without parallel processing.  `tune_grid()` (and `fit_resamples()`) default is to allow parallel processing so have to explicitly turn it off using `control_grid()`.  You will NOT do this.  It is only to show the benefits of parallel processing.


```{r}
tic()
linear_reg(penalty = tune(), mixture = tune()) %>% 
  set_engine("glmnet") %>% 
  tune_grid(preprocessor = rec, 
            resamples = splits, grid = tune_grid, 
            metrics = metric_set(rmse),
            control = control_grid(allow_par = FALSE)) # turn off pp
toc()
```


Now with the use of a plan from furture package
```{r} 
# library(future)  # need this loaded at top of script to use plan()
plan(multisession, workers = parallel::detectCores(logical = FALSE))

tic()
linear_reg(penalty = tune(), mixture = tune()) %>% 
  set_engine("glmnet") %>% 
  tune_grid(preprocessor = rec, 
            resamples = splits, grid = tune_grid, 
            metrics = metric_set(rmse))
toc()

plan(sequential)
```


### foreach()

`foreach()` in sequential mode using `%do%`
```{r}
tic()
x <- foreach(time = c(2, 2, 2), .combine = "c") %do% {
  Sys.sleep(time)
  time
}
toc()
```


foreach supports parallel processing with the future backend.   There are two additiona adjustments needed

- library(doFuture) needs to be loaded
- and %dofuture% replaces %do% (or the previously used %dopar%)

```{r}
# library(future)  # need this loaded at top of script to use plan
library(doFuture) # also need doFuture to use %dofuture% with foreach

plan(multisession, workers = parallel::detectCores(logical = FALSE))

tic()
x <- foreach(time = c(2, 2, 2), .combine = "c") %dofuture% {
  Sys.sleep(time)
  time
}
toc()

plan(sequential)
```


Need a demo for how to handle random numbers. No error or warning here but `%dorng%` is recommended I think?
```{r}
tic()
x <- foreach(time = c(2, 2, 2), .combine = "c") %dopar% {
  Sys.sleep(time)
  rnorm(1)
}
toc()
```